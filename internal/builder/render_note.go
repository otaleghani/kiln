package builder

import (
	"bytes"
	"fmt"
	"html/template"
	"log"
	"os"

	"github.com/tdewolff/minify/v2"
	"github.com/yuin/goldmark"
	meta "github.com/yuin/goldmark-meta"
	"github.com/yuin/goldmark/ast"
	"github.com/yuin/goldmark/parser"
	"github.com/yuin/goldmark/text"
)

// PageData is the payload passed to the HTML templates for rendering.
type PageData struct {
	Title         string
	Content       template.HTML
	SiteName      string
	WebPath       string
	CanvasContent template.JS // Raw JS JSON for canvas hydration
	IsCanvas      bool
	IsGraph       bool
	Breadcrumbs   []string
	Sidebar       []*Node
	Frontmatter   map[string]any
	TOC           template.HTML
	BaseURL       string
	Font          FontData
}

// MarkdownNoteRenderer handles the conversion of standard Markdown files.
// It manages the full pipeline: AST parsing, TOC extraction, HTML rendering, and post-processing.
type MarkdownNoteRenderer struct {
	path           string             // Absolute source path
	nameWithoutExt string             // Filename without extension (slug)
	siteName       string             // Global site name
	relPath        string             // Path relative to input directory
	baseURL        string             // Site Base URL
	renderer       goldmark.Markdown  // Shared Markdown instance
	rootNode       *Node              // Navigation tree root
	template       *template.Template // Main HTML layout
	minifier       *minify.M          // HTML minifier
	theme          Theme              // Visual theme settings
}

// render processes the markdown file and writes the final HTML to disk.
// It returns the web-accessible path for the generated page.
func (m *MarkdownNoteRenderer) render() string {
	breadcrumbs := getBreadcrumbs(m.relPath, m.nameWithoutExt)

	source, err := os.ReadFile(m.path)
	if err != nil {
		log.Printf("Failed to read markdown note: %s. Error: %s", m.path, err.Error())
		return ""
	}

	outPath, webPath := getPageOutputPath(m.relPath, m.nameWithoutExt, ".md")

	// We separate Parsing and Rendering to inspect the AST (Abstract Syntax Tree)
	// This allows us to extract metadata (Frontmatter) and generate the TOC before rendering HTML.
	ctx := parser.NewContext()
	doc := m.renderer.Parser().Parse(text.NewReader(source), parser.WithContext(ctx))

	// Generate Table of Contents from the AST
	tocHTML := extractTOC(doc, source)

	// Render the actual HTML body
	var buf bytes.Buffer
	if err := m.renderer.Renderer().Render(&buf, source, doc); err != nil {
		log.Printf("Failed to render markdown: %s. Error: %s", m.path, err.Error())
		return ""
	}

	// Apply post-processing transformers
	finalHTML := buf.String()
	finalHTML = transformCallouts(finalHTML)
	finalHTML = transformMermaid(finalHTML)
	finalHTML = transformHighlights(finalHTML)

	// Update navigation tree state
	setTreeActive(m.rootNode.Children, webPath)

	f, err := os.Create(outPath)
	if err != nil {
		log.Printf("Failed to create output file: %s. Error: %s", outPath, err.Error())
		return ""
	}
	defer f.Close()

	// Wrap output writer with minifier
	mw := m.minifier.Writer("text/html", f)
	defer mw.Close()

	data := PageData{
		BaseURL:     m.baseURL,
		Title:       m.nameWithoutExt,
		WebPath:     webPath,
		SiteName:    m.siteName,
		Content:     template.HTML(finalHTML),
		Breadcrumbs: breadcrumbs,
		IsCanvas:    false,
		IsGraph:     false,
		TOC:         tocHTML,
		Sidebar:     m.rootNode.Children,
		Frontmatter: meta.Get(ctx),
		Font:        m.theme.Font,
	}

	m.template.Execute(mw, data)

	return webPath
}

// extractTOC walks the AST to generate a flat HTML list for the Table of Contents.
// It uses CSS classes (e.g., .toc-level-2) to handle indentation instead of nested <ul>s.
func extractTOC(doc ast.Node, source []byte) template.HTML {
	var listBuf bytes.Buffer
	hasHeadings := false

	ast.Walk(doc, func(n ast.Node, entering bool) (ast.WalkStatus, error) {
		// Only process headings on entry
		if !entering || n.Kind() != ast.KindHeading {
			return ast.WalkContinue, nil
		}

		h := n.(*ast.Heading)

		// Extract HTML ID (generated by Goldmark auto-id)
		var id string
		if val, ok := h.Attribute([]byte("id")); ok {
			if idBytes, ok := val.([]byte); ok {
				id = string(idBytes)
			}
		}

		text := string(h.Text(source))

		// Render list item with level-specific class
		listBuf.WriteString(fmt.Sprintf(
			"<li class=\"toc-level-%d\"><a href=\"#%s\">%s</a></li>",
			h.Level, id, text,
		))
		hasHeadings = true

		return ast.WalkContinue, nil
	})

	if !hasHeadings {
		return template.HTML("")
	}

	return template.HTML("<nav class=\"toc\"><ul>" + listBuf.String() + "</ul></nav>")
}
